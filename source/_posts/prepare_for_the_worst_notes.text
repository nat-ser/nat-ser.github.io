
--nick cage crazy laughing
{% img http://c2.thejournal.ie/media/2014/04/klyjglz.gif %}

-christopher walken
{% img https://media.giphy.com/media/P9okXOaxAC02k/giphy.gif %}

--zach fern in face
{% img https://45.media.tumblr.com/17f9e922c8eeaa42a20deb1adcc023ed/tumblr_neuz7ax3491qzt3zao1_500.gif %}

--nick cage afraid
{% img http://i.imgur.com/iVXxL.gif %}

--great job steve brule
{% img http://cdn3.sbnation.com/imported_assets/1711759/DrSteveBrule.gif %}

--i know steve brule
{%img http://i.imgur.com/qQ9ifnb.gif %}

--bringo
http://25.media.tumblr.com/tumblr_m4atciViUb1qz9y4so1_500.png

--i love riddles ron swanson
http://cdn1.theodysseyonline.com/files/2015/10/31/635818589835734249370285774_1dfc00bbdb005b909c17c2a19667e8a1.gif


--leo strutting from zombies
http://assets0.ordienetworks.com/images/user_photos/1141187/tumblr_l8143ibEPs1qdwsne_fullsize.jpeg?2894b262


--leo because it's awesome
http://24.media.tumblr.com/6c2d6ce1418648170c277d2ae5562266/tumblr_n06j265WVR1r7572oo6_r2_400.gif



4) Reserved Words
They cannot be used to name variables or parameters. When reserved words are
used as keys in object literals, they must be quoted. They cannot be used with the
dot notation, so it is sometimes necessary to use the bracket notation instead:
var method; // ok
var class; // illegal
object = {box: value}; // ok
object = {case: value}; // illegal
object = {'case': value}; // ok
object.box = value; // ok
object.case = value; // illegal
object['case'] = value; // ok

5) typeof
.is_a?(String)
produces 'number'. Unfortunately:
typeof null
returns 'object' instead of 'null'. Oops. A better test for null is simply:
my_value === null

typeof cannot distinguish between null and objects, but you can because null is falsy and all objects are truthy:
what you should do:
if (my_value && typeof my_value === 'object') {
 // my_value is an object or an array!
}






6) ParseInt
parseInt("16") and parseInt("16 tons") produce the same result.
parseInt("08") and parseInt("09") produce
0 as their result. This error causes problems in programs that parse dates and
times. Fortunately, parseInt can take a radix parameter, so that parseInt("08",10)
produces 8. I recommend that you always provide the radix parameter.

7) Floating Point
 0.1 + 0.2 is not equal to 0.3.
  This is the most frequently reported bug in JavaScript, and it is an
intentional consequence of having adopted the IEEE Standard for Binary FloatingPoint
Arithmetic (IEEE 754). This standard is well-suited for many applications,
but it violates most of the things you learned about numbers in middle school.
so decimal representation
errors can be avoided by scaling.
For example, dollar values can be converted to whole cents values by multiplying
them by 100. The cents then can be accurately added. The sum can be divided by
100 to convert back into dollars. People have a reasonable expectation when they
count money that the results will be exact.

8) FalsyValues
Table A-1. The many falsy values of JavaScript
Value Type
0 Number
NaN (not a number) Number
'' (empty string) String
false Boolean
null Object
undefined Undefined

9)
JavaScript has two sets of equality operators: === and !==, and their evil twins == and
!=. The good ones work the way youwould expect. If the two operands are of the
same type and have the same value, then === produces true and !== produces false.
The evil twins do the right thing when the operands are of the same type, but if they
are of different types, they attempt to coerce the values. The rules by which they do
that are complicated and unmemorable. These are some of the interesting cases:
'' == '0' // false
0 == '' // true
0 == '0' // true
false == 'false' // false
false == '0' // true
false == undefined // false
false == null // false
null == undefined // true
' \t\r\n ' == 0 // true

freaks out if you have two things of different types

10) With statement
-a with statement that was intended to provide a shorthand when
accessing the properties of an object
-unpredictable
-by being in the language, the with statement significantly slows down JavaScript
processors because it frustrates the lexical binding of variable names. It was well intentioned,
but the language would be better if it didn’t have it.

11)  eval("myValue = myObject." + myKey + ";");
instead of:
myvalue = myObject[myKey];
Messes with speed of programs  needs to run the compiler just to execute a trivial assignment statement

12)continue

13) switch fall through
Someone wrote to me once suggesting that JSLint should give a warning when a case
falls through into another case



16)
The only way to remove a property from an object is to use the delete operator; setting the property to undefined or null only removes the value associated with the property, but not the key.


“JavaScript: The Good Parts by Douglas
Crockford. Copyright 2008 Yahoo! Inc., 978-0-596-51774-8.”

http://bonsaiden.github.io/JavaScript-Garden/
